openapi: 3.0.3
info:
  title: Swagger Petstore - OpenAPI 3.0
  description: |-
    Week 2 assignment for Advanced Serverside Languages (WDV442). This document outlines all of the expected endpoints for the contact book assignment for week 2. Each endpoint below outlines the expected support for each route/endpoint. The following lists out all of the things that will be tested against:
    
        - Custom HTTP header support
        - Support for dynamic URL/path segments
        - Proper RESTful implementation
        - Different body payloads & data types
        - Controller filtering, and sorting logic
        - Usage of correct HTTP response codes
        
      ## Key Features:
      1) **Pagination**: Contacts are not returned in a single response. Users are required to utilize the 'X-Page-Next' and 'X-Page-Prev' headers to interact with the data. Pagination logic is primarily handled by the @jworkman-fs/asl library, although you can choose to implement it yourself for a challenge.
      2) **Sorting**: The result set supports sorting by any field in ascending or descending order. This logic is also managed through the **@jworkman-fs/asl** library, with the option for custom implementation.
      3) **Filtering**: You must add the ability to apply filters to the results, targeting any of the four primary fields with dynamic comparison operators such as equal to, greater than, or less than. Most of this logic occurs within the **@jworkman-fs/asl** library.
      
      # Filtering
      
      To integrate filtering logic into your API endpoint, utilize methods from the @jworkman-fs/asl npm package. Filtering logic should precede other logic in the order of Filtering -> Sorting -> Pagination. Notably, filtering at this endpoint is performed through headers, not query parameters. This practice, although technically unconventional, is designed to enhance HTTP protocol skills.
      
      Its also extremely important to note that filtering on this endpoint is done through headers. **Do not use query parameters for filtering logic.** It will cause your tests to fail. I know technially doing it through query parameters are the correct way, however we are trying to practice all of our HTTP protocol skills (including the use of custom headers). 
      
      ## <u>filterContacts( dataset, by, operator, value )</u> _-> array_
      
      This function returns a filtered dataset of Contacts based on the provided filtering arguments.
      
      - _(array)_ <u>**dataset**</u>: The complete list of results for filtering, typically the entire contact list.
      - _(enum)_ <u>**by**</u>: A string limited to one of four values (fname, lname, email, or birthday), commonly referred to as an "enum" in computer science.
      - _(enum)_ <u>**operator**</u>: An enum set to one of five values (eq, gt, gte, lt, or lte), indicating the comparison operator for filtering.
      - _(any)_ <u>**value**</u>: The value that you want to compare the "by" field to. 
      
      ## <u>Filtering Example</u>
      
      The following lines of code show how to apply the filtering logic to your Contacts result set using the **@jworkman-fs/asl** npm package library.
      
          const filtered = Contact.filter( contacts, req.get('X-Filter-By'), req.get('X-Filter-Value') )
          res.json(filtered)
      
      ## <u>Sorting Example</u>
      
      The following lines of code show how to apply the sorting logic to your Contacts result set using the **@jworkman-fs/asl** npm package library.
      
        const sorted = sortContacts( contacts, req.query.sort, req.query.direction )
        res.json(sorted)
      
      
      # Sorting
      
      In order to integrate sorting logic into your API endpoint you will need to utilze a few methods from the **@jworkman-fs/asl** npm package you installed. You should normally do your sorting logic right after your filtering logic, but before your pagination logic. The order of logic should generally go in the order of: Filtering -> Sorting -> Pagination. 
      
      ## <u>sortContacts( dataset, by, direction )</u> _-> array_
      
      This simple function will return an array of sorted contacts. 
      
      - _(array)_ <u>**dataset**</u>: The **dataset** argument is the entire list of results you want sorted. In this case it would be the entire contact list.
      - _(enum)_ <u>**by**</u>: The **sortBy** argument is a string that can only be set to 1 of four values (fname, lname, email, or birthday). In the computer science industry we call this an "enum."
      - _(enum)_ <u>**direction**</u>: The **direction** argument is used to set the direction of the sorting when applied to the **sortBy** field. It can only be 1 of two values (asc, or desc) which makes it an enum. 
      
      ## <u>Sorting Example</u>
      
      The following lines of code show how to apply the sorting logic to your Contacts result set using the **@jworkman-fs/asl** npm package library.
      
        const sorted = sortContacts( contacts, req.query.sort, req.query.direction )
        res.json(sorted)
      
      # Pagination
      
      In order to hook up pagination support (the ability to navigate through your contacts page-by-page) you will need to pass all of the request data, and pagination context through to the **@jworkman-fs/asl** package in order to get a paginated result set returned. You will need to use the "Pager" class documented below in order to fully integrate this endpoint.
      
      ## <u>Pager( dataset, page, limit )</u>
      
      This class simply needs to be instantiated/invoked with the _**new**_ keyword. It takes the following three arguments:
      
      - _(array)_ <u>**dataset**</u>: The **dataset** argument is the entire list of results you want paginated. In this case it would be the entire contact list.
      - _(integer)_ <u>**page**</u>: The **page** argument is an integer that points to the current page the user is requesting to view out of the entire set of pages. Think of this argument like a bookmark. It tells the paginator what page the user is currently viewing. 
      - _(integer)_ <u>**limit**</u>: The **limit** argument sets the maximum number of results that can be displayed on any given page. The default value for this argument is 10, but can be increased, or decreased. The paginator needs to know how many results live on each page in order to properly calculate how many pages in total there are. 
      
      <u>**Pager.results()**</u> _-> array_
      
      Invoke this method whenever you are ready to get the final result set based on all of the pagination context. This method will return only the results that are being requested in the request. 
      
      <u>**Pager.total()**</u> _-> integer_
      
      This method will return the total number of results not based on pagination context. This method will need to be invoked in order to set the 'X-Page-Total' header inside the response. This lets the user know where they are in the pagination context when compared to the total number of results in the paginator. 
      
      <u>**Pager.next()**</u> _-> integer_
      
      This method simply returns the next page number from the current pagination context. For instance if the user requested page number 3, and there are 5 pages in total, then the value returned from this method would equal 4. However if the user is currently viewing the **last** page in the pagination stack then it will simply return the maximum number of pages which is 5. 
      
      <u>**Pager.prev()**</u> _-> integer_
      
      This method simply returns the previous page number from the current pagination context. For instance if the user requested page number 3, and there are 5 pages in total, then the value returned from this method would equal 2. However if the user is currently viewing the **first** page in the pagination stack then it will simply return the minimum number of pages which is 1. 
      
      ## <u>Pagination Example</u>
      
      The following lines of code show how to use the Pagination component from the **@jworkman-fs/asl** npm package inside your controller. Note that pagination logic normally always goes last (after sorting, and filtering) since the pagination should only apply to the final result set. 
      
        const pager = new Pager( contacts, req.query.page, req.query.size )
        res.set("X-Page-Total", pager.total())
        res.set("X-Page-Next", pager.next())
        res.set("X-Page-Prev", pager.prev())
        res.json(pager.results())
          
      # Handling Errors
      
      Modern APIs and applications have shifted from monolithic error handling to exception handling for more nuanced responses. This involves using try/catch blocks for handling various types of exceptions during CRUD operations.
      
      The following example you can see how I want you to handle potential errors by setting up catch blocks for all of the different types of exceptions that may arise from performing simple CRUD operations in a RESTful context. As you can tell I obviously prefer to use a nice switch case on my exception handling, but feel free to use a standard if/else block if you prefer it the other way. 
      
        import { ContactModel } from "@jworkman-fs/asl"
          
        const update = (req, res) => {
          try { // Place your CRUD code here inside the try block
          
            // Update the contact
            ContactModel.update( req.params.id, res.body )
            
            // Issue the redirect
            res.status( 303 ).redirect( `/contacts/${req.params.id}` )
            
          } catch (e) { // Define your error handling here in the catch block
          
            switch(typeof e) {
              case "InvalidContactError":
                return res.status(400).json({ message: e.message })
                break;
              case "ContactNotFoundError":
                return res.status(404).json({ message: e.message })
                break;
              default:
                return res.status(500).json(e)
                break;
            }
          }
        }
        
      In the list below, you will find all the exceptions available from the **@jworkman-fs/asl** library. You are required to utilize these exceptions at various points within your REST controller. Ensure that each exception is mapped to its corresponding status code, as the test will verify the accuracy of your status codes to confirm their proper usage. The required status codes for each endpoint are detailed in this document. Note that each endpoint may need to support different status codes depending on various scenarios and use cases. 
      
      | Error Class Name               | Description                                                                                                                                                 |
      |------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
      | **ContactNotFoundError**       | Thrown whenever a contact could **not** be found by the id that was specified                                                                               |
      | **DuplicateContactResourceError**      | Thrown whenever a duplicate contact with the same email was found when attempting to create a new one.                                                      |
      | **InvalidContactError**        | Thrown whenever a contact is invalid. Three other exceptions inherit from this one so this one is considered a generic/catch all exception                  |
      | **InvalidContactFieldError**   | Thrown whenever a specific field value fails validation (such as an invalid email, or phone format)                                                         |
      | **InvalidContactSchemaError**  | Thrown whenever a field outside of the original four (lname, fname, phone, or email) was given to the ContactModel, or one of those fields were missing. |
      | **PagerOutOfRangeError**        | Thrown whenever the user has requested a page that is out of range for the paginator. For example requesting page 10 when there are only 5 pages in total.  |
      | **InvalidEnumError**           | Thrown whenever one of the enum type parameters (such as sort) is set to an invalid value other than the ones defined by the enum itself                    |
      | **PagerLimitExceededError**     | Thrown whenever the user has requested the number of results to be higher than the absolute maximum limit of 20 results per page.                           |
      
      
  version: 1.0.1
servers:
  - url: http://localhost:8080
tags:
  - name: contacts
    description: Contacts store in contact book
paths:
  /contacts:
    get:
      tags:
        - contacts
      summary: List of contacts
      description: |-
        This endpoint offers a set of contacts based on pagination context, enabling comprehensive pagination functionality. Rather than delivering all contacts in a single response, users must navigate through the contact data using 'X-Page-Next' and 'X-Page-Prev' headers for sequential access.

          # Testing This Endpoint
          The command below is a cURL example designed to fetch all contacts with a birthday on or after 1980, sorted by last name in descending order, and sets the page to 2 in the pagination context. This command serves as a quick test to verify that your API is functioning correctly. Ensure that the returned data and headers accurately reflect the specified filtering conditions:
          
            curl -X GET \ 
            -H "X-Filter-By: birthday" -H "X-Filter-Operator: gte" -H "X-Filter-Value: 1980-01-01" \
            http://localhost:8080/contacts?page=2&sort=lname&direction=desc&size=5
      parameters:
        - name: page
          in: query
          description: |-
            This parameter sets the page number within the pagination context. It is important to note that requests for pages out of the available range will be rejected by the API.
          required: false
          schema:
            type: integer
            default: 1
        - name: sort
          in: query
          description: |-
            This parameter sets the field by which the contact data should be sorted. Valid options are 'fname', 'lname', 'email', or 'birthday'. Any values other than these will be rejected by the API with a 400 status code.
          required: false
          schema:
            type: string
            default: fname
            enum:
              - fname
              - lname
              - email
              - birthday
        - name: direction
          in: query
          description: |-
            This parameter determines the sorting order of the contacts list within a paginated context. It accepts only two values: 'asc' for ascending order, or 'desc' for descending order. Any other values provided will be rejected by the API with a 400 status code. 
          required: false
          schema:
            type: string
            default: asc
            enum:
              - asc
              - desc
        - name: size
          in: query
          description: |-
            This parameter specifies the maximum number of contacts that can be displayed on a single page. Note that the limit cannot exceed 20 contacts per response.
          required: false
          schema:
            type: integer
            maximum: 20
            default: 10
        - name: X-Filter-By
          in: header
          description: |-
            This header enables users to filter and narrow down the set of contacts based on a specific field. It allows for more targeted and efficient retrieval of contact information. This is the first of three headers that are required in order to use filtering. 
          required: false
          schema:
            type: string
            enum:
              - fname
              - lname
              - email
              - birthday
        - name: X-Filter-Operator
          in: header
          description: |-
            This header defines the type of filter to be applied to the field specified in the 'X-Filter-By' header. For instance, if the value is set to 'gte', the filtering logic will apply the greater-than-or-equal-to operator ('>='). It is important to note that the API only supports the following filtering logic operators: 'eq' (equal), 'gt' (greater than), 'gte' (greater than or equal to), 'lt' (less than), and 'lte' (less than or equal to). Any values other than these must be rejected by the API with a 400 status code.
          required: false
          schema:
            type: string
            enum:
              - eq
              - gt
              - gte
              - lt
              - lte
        - name: X-Filter-Value
          in: header
          description: |-
            This header sets the value for the filtering condition logic and represents the third and final 'X-Filter' header. When all three 'X-Filter' headers are present in a request, specific filtering logic is applied.
            
            Consider the following HTTP request as an example to understand the corresponding filter logic translation:
            
                GET /contacts HTTP/1.1
                X-Filter-By: birthday
                X-Filter-Operator: gte
                X-Filter-Value: 1990-01-01
                
            Translating the headers into a practical example yields the following filter logic:
                 
                if (contact.birthday  >=  "1990-01-01") {...}
          required: false
          schema:
            type: string
      responses:
        200:
          description: List of contacts inside the pagination context.
          content:
            application/json:
              schema:
                type: array
                description: An array/set of contacts after being sorted, filtered, and paginated.
                items:
                  $ref: '#/components/schemas/Contact'
          headers:
            X-Results-Total: 
              description: |-
                This header must match the total count of results obtained after applying filters to the result set. This alignment is crucial for implementing pagination design patterns effectively. Given that a browser is limited to displaying only a specified number of results simultaneously, it's necessary to provide a method for accurately informing the browser about the complete number of results available.
              schema:
                type: string
                format: uri
        416:
          description: |- 
            This status code is only sent when the user attempts to request a page outside the current result set. In other words if the user requests page "7", but there are only 6 pages of results to display then a 416 (Range Not Satisfiable) status code needs to be returned.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
        400:
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
          description: |-
            A status code of 400 (Bad Request) will be returned whenever any input values in the request are not acceptable. For instance, if a request to the API includes a value of '1' for the 'sort' query parameter, and since this parameter only accepts 'asc' or 'desc', the request should be rejected with a 400 status code. This principle applies uniformly to all parameters, headers, and URL segments. If any user input is invalid, the request should be rejected and a 400 status code will be issued.
    post:
      tags:
        - contacts
      summary: Creates a new contact
      description: |-
        Creates a new Contact inside the contacts array list. It accepts a Contact object in the request's body/payload. You will need to run the incoming data fields through the "validateContact(data)" function from the **@jworkman-fs/asl** npm package. If validation fails it will throw a InvalidContactError which will need to be properly handled by a try/catch statement. 
        
        # NPM Package Usage
        
        Your assignment is already configured to integrate with the **@jworkman-fs/asl** npm package/library. This endpoint will utilize the following functions from the library. Note that you are welcome to code out your own library if you want to challenge yourself even more, however it is recommended to utilize my package code if you are on a time crunch. 
        
        ## <u>Contact.validate( _fields_ )</u>
        
        This function validates a single JavaScript object that contains the four primary fields for a Contact (fname, lname, email, and phone). It uses exceptions as its method of raising errors/exceptions. So this method does not return true, or false if the validation passed, or failed. Instead it will throw a different exception for any error that it encounters. Errors allow us to handle many different types of errors in a cleaner way versus simple boolean return values which can easily lead down a messy bloated path when it comes to managing many different types of error that could happen. 
        
          In order to use this validation function you must wrap it inside its own try/catch block. Then you must define an exception handler for each indevidual exception listed below. There are a few different types of exceptions that are thrown by this function. Below is a complete list you will need to listen for in your controller code for this endpoint: 
          
          - **InvalidContactFieldError,** - This exception is thrown when any one of the four primary fields are invalid.
          - **BlankContactFieldError** - This exeption is thrown when a one of the values in the _fields_ argument is left blank.
          - **DuplicateContactResourceError** - This exception is thrown when a contact with the same email as the one being requested already exists in the contacts book.
          - **InvalidContactSchemaError** - This exception is thrown when the data inside the _fields_ argument do not match the schema outlined for the _fields_ argument. The _fields_ argument either was missing one of the four primary fields, or had additional fields not defined by the original four. 
          
        Some other errors/exceptions you can catch: 
        - InvalidContactResourceError
        - PagerError
        - PagerNoResultsError
        - PagerOutOfRangeError
        - NoContactsFoundError
        
        ## <u>Contact.create( _fields_ )</u>
        
        This function appends a new Contact to the contacts array/list using the fields defined inside the _fields_ argument. Note that this function should only be invoked after validation is completed. Otherwise you run the risk of storing bad, or potentially unsafe data inside your contacts array.
        
        # Testing This Endpoint
        You can test this endpoint by running the following curl command: 
        
            curl -X POST --data "fname=John&lname=Doe&email=jdoe@example.com&phone=+1-555-555-5555" \
              http://localhost:8080/contacts
        
        Please note that you need to check the response, headers, and data to make sure everything looks correct for this endpoint. To test other parts of this endpoint you will need to change the cURL command to fit your testing needs. This is just a generic testing command writen to create a generic Contact. The test script from the **@jworkman-fs/asl** package will test this endpoint in depth. 
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Contact'
      responses:
        303:
          description: |-
            A special redirect using a status code of "303" should be used when in a RESTful context after the user has submitted a new entity since we want to discurage any browser caching, or even duplicate re-submissions which is precisly what the 303 status code was built for. It is extremely important to issue a redirect to the newly created Contact show endpoint. For example if a new Contact was created with an id of "487" then the API must redirect the user to "/contacts/487" using the GET method. 
          headers:
            Location: 
              description: |-
                URL to the show endpoint with the newly created Contact's ID: /contacts/478
              schema:
                type: string
                format: uri
        400:
          description: |-
            A 400 status code should be thrown when the user failed to submit valid data to the request. This should be thrown when an InvalidContactError is thrown by the **@jworkman-fs/asl** npm package. 
  /contacts/{id}:
    get:
      tags:
        - contacts
      summary: Displays a single contact by their id
      description: |-
        Fetches a single contact by its id field. This should only return a single contact. 
      parameters:
        - name: id
          in: path
          description: The id of the contact to query by
          required: true
          schema:
            type: integer
      responses:
        200:
          description: Full details of a single contact
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Contact'
        400:
          description: Gets thrown when the user attempted to submit invalid input into the ID field such as a string, or non integer value.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
        404:
          description: Gets thrown when the contact could not be found by the id requested. 
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
    put:
      tags:
        - contacts
      summary: Updates a single contact
      description: |-
        This endpoint fetches a contact from our contacts by its id. Then it applies new updated fields to it. Then overwrites the original inside the contacts array. Its important to note that the payload data for this endpoint will be in JSON format. That means that the Content-Type will be set to "application/json" instead of the default "application/x-www-form-urlencoded" value that browsers use for submitting form field data. 
      parameters:
        - name: id
          in: path
          description: The id of the contact to query by
          required: true
          schema:
            type: integer
      requestBody:
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/Contact'
      responses:
        303:
          description: |-
            A special redirect using a status code of "303" should be used when in a RESTful context after the user has updated a specific contact by id since we want to discurage any browser caching, or even re-submission requests which is precisly what the 303 status code was built for. 
          headers:
            Location: 
              description: |-
                URL to the show contact by id at GET /contacts/:id
              schema:
                type: string
                format: uri
        400:
          description: |- 
            Gets thrown when the user attempted to submit invalid input into the ID field such as a string, or non integer value. Also if any of the fields are invalid (fname, lname, email, or phone) are not valid then the API must reject the request with a 400 request. You can use the "validateContact(data)" function from the **@jworkman-fs/asl** npm pacakge to validate the incoming contact data that is being submitted. Note that you MUST wrap the "validate" function call inside a try catch statement in order to catch the "InvalidContactError" when validation fails. Then inside the catch block you must return the API 400 error. 
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
        404:
          description: Gets thrown when the contact could not be found by the id requested. 
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
    delete:
      tags:
        - contacts
      description: |-
        Removes a single Contact by its ID. User of API is then redirected back to the list of all contacts at "/contacts" using the GET method. 
      parameters:
        - name: id
          in: path
          description: The id of the contact to be removed from the list
          required: true
          schema:
            type: integer
      responses:
        303:
          description: |-
            A special redirect using a status code of "303" should be used when in a RESTful context after the user has removed an entity since we want to discurage any browser caching, or even duplicate removals requests which is precisly what the 303 status code was built for. 
          headers:
            Location: 
              description: |-
                URL to the index view at GET /contacts
              schema:
                type: string
                format: uri
        400:
          description: |- 
            Gets thrown when the user attempted to submit invalid input into the ID field such as a string, or non integer value.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'
        404:
          description: Gets thrown when the contact could not be found by the id requested.
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ErrorMessage'

components:
  schemas:
    Contact:
      type: object
      properties:
        fname:
          type: string
          example: John
        lname:
          type: string
          example: Doe
        email:
          type: string
          example: jdoe@example.com
        birthday:
          type: string
          example: "1982-01-22"
    ErrorMessage:
      type: object
      properties:
        message:
          type: string
          example: |-
            An error has occured: <error message goes here...>
